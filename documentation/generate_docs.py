import json
import os
import time
from dotenv import load_dotenv
from google import genai
from google.genai import types, errors

# ---------------------------------------------------------
# SETUP
# ---------------------------------------------------------
load_dotenv()
# Ensure your .env file has GEMINI_API_KEY=...
client = genai.Client(api_key=os.environ.get("GEMINI_API_KEY"))

# ---------------------------------------------------------
# HELPER FUNCTIONS
# ---------------------------------------------------------
def generate_table_documentation(table_name, table_data):
    # NOTE: variable renamed to 'table_data' to imply it contains both columns & foreign_keys
    
    # FIX: Double curly braces {{ }} used for AI instructions
    prompt = f"""
    You are a Senior Database Architect documenting a SQL Server database.

    TABLE NAME: {table_name}

    SCHEMA CONTEXT:
    {json.dumps(table_data, indent=2)}

    TASK:
    1. **Description**: Write a concise summary of the table's purpose.
    2. **Columns**: Create a Markdown table of columns (Name, Type, Description).
    3. **Relationships**: 
    - Analyze the "foreign_keys" list in the provided JSON.
    - For every foreign key, write a bullet point: "The column `{{column}}` links to the `{{references_table}}` table."
    - If no foreign keys exist, state "This is a standalone reference table."
    4. **Visuals (Mermaid.js)**:
    - Generate a Mermaid `erDiagram` code block.
    - Define the entity `{table_name}`.
    - If foreign keys exist, draw the relationship arrows to the referenced tables (e.g., `{table_name} }}|..|| ReferencedTable : links_to`).

    Output strictly in Markdown.
    """

    # RETRY LOGIC
    max_retries = 3
    retry_delay = 30 

    for attempt in range(max_retries):
        try:
            # FIX: Updated model name to a valid version
            response = client.models.generate_content(
                model="gemini-2.5-flash", 
                contents=prompt,
                config=types.GenerateContentConfig(
                    system_instruction="You are a helpful database documentation assistant.",
                    temperature=0.1
                )
            )
            return response.text

        except errors.ClientError as e:
            if e.code == 429:
                print(f"‚ö†Ô∏è Quota hit for '{table_name}'. Cooling down for {retry_delay}s... (Attempt {attempt+1}/{max_retries})")
                time.sleep(retry_delay)
            else:
                print(f"‚ùå API Error for '{table_name}': {e}")
                return f"Error documenting {table_name}: {e.message}"
    
    return f"Failed to document {table_name} after rate limit retries."

# ---------------------------------------------------------
# MAIN EXECUTION
# ---------------------------------------------------------
def main():
    # Ensure this matches the filename output by your extractor script
    schema_path = os.path.join(os.path.dirname(__file__), 'db_schema.json')
    output_path = os.path.join(os.path.dirname(__file__), 'Technical_Docs.md')

    try:
        with open(schema_path, 'r') as f:
            schema = json.load(f)
    except FileNotFoundError:
        print("Error: db_schema.json not found. Did you run the extractor script?")
        return

    with open(output_path, 'w') as f:
        f.write("# Database Documentation\n\n_Auto-generated by Gemini_\n\n")

    print(f"Starting documentation for {len(schema)} tables...")

    for table_name, table_data in schema.items():
        print(f"üìÑ Processing: {table_name}...")
        
        doc_segment = generate_table_documentation(table_name, table_data)
        
        with open(output_path, 'a') as f:
            f.write(f"## Table: {table_name}\n\n")
            f.write(doc_segment + "\n\n---\n\n")

        # Smart Rate Limiting for Free Tier
        print("   ...Done. Sleeping 5s.")
        time.sleep(5) 

    print(f"‚úÖ Full documentation saved to {output_path}")

if __name__ == "__main__":
    main()